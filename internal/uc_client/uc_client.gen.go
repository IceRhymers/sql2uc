// Package uc_client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package uc_client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ColumnTypeName.
const (
	ARRAY           ColumnTypeName = "ARRAY"
	BINARY          ColumnTypeName = "BINARY"
	BOOLEAN         ColumnTypeName = "BOOLEAN"
	BYTE            ColumnTypeName = "BYTE"
	CHAR            ColumnTypeName = "CHAR"
	DATE            ColumnTypeName = "DATE"
	DECIMAL         ColumnTypeName = "DECIMAL"
	DOUBLE          ColumnTypeName = "DOUBLE"
	FLOAT           ColumnTypeName = "FLOAT"
	INT             ColumnTypeName = "INT"
	INTERVAL        ColumnTypeName = "INTERVAL"
	LONG            ColumnTypeName = "LONG"
	MAP             ColumnTypeName = "MAP"
	NULL            ColumnTypeName = "NULL"
	SHORT           ColumnTypeName = "SHORT"
	STRING          ColumnTypeName = "STRING"
	STRUCT          ColumnTypeName = "STRUCT"
	TABLETYPE       ColumnTypeName = "TABLE_TYPE"
	TIMESTAMP       ColumnTypeName = "TIMESTAMP"
	TIMESTAMPNTZ    ColumnTypeName = "TIMESTAMP_NTZ"
	USERDEFINEDTYPE ColumnTypeName = "USER_DEFINED_TYPE"
)

// Defines values for CreateFunctionParameterStyle.
const (
	CreateFunctionParameterStyleS CreateFunctionParameterStyle = "S"
)

// Defines values for CreateFunctionRoutineBody.
const (
	CreateFunctionRoutineBodyEXTERNAL CreateFunctionRoutineBody = "EXTERNAL"
	CreateFunctionRoutineBodySQL      CreateFunctionRoutineBody = "SQL"
)

// Defines values for CreateFunctionSecurityType.
const (
	CreateFunctionSecurityTypeDEFINER CreateFunctionSecurityType = "DEFINER"
)

// Defines values for CreateFunctionSqlDataAccess.
const (
	CreateFunctionSqlDataAccessCONTAINSSQL  CreateFunctionSqlDataAccess = "CONTAINS_SQL"
	CreateFunctionSqlDataAccessNOSQL        CreateFunctionSqlDataAccess = "NO_SQL"
	CreateFunctionSqlDataAccessREADSSQLDATA CreateFunctionSqlDataAccess = "READS_SQL_DATA"
)

// Defines values for DataSourceFormat.
const (
	AVRO    DataSourceFormat = "AVRO"
	CSV     DataSourceFormat = "CSV"
	DELTA   DataSourceFormat = "DELTA"
	JSON    DataSourceFormat = "JSON"
	ORC     DataSourceFormat = "ORC"
	PARQUET DataSourceFormat = "PARQUET"
	TEXT    DataSourceFormat = "TEXT"
)

// Defines values for FunctionInfoParameterStyle.
const (
	FunctionInfoParameterStyleS FunctionInfoParameterStyle = "S"
)

// Defines values for FunctionInfoRoutineBody.
const (
	FunctionInfoRoutineBodyEXTERNAL FunctionInfoRoutineBody = "EXTERNAL"
	FunctionInfoRoutineBodySQL      FunctionInfoRoutineBody = "SQL"
)

// Defines values for FunctionInfoSecurityType.
const (
	FunctionInfoSecurityTypeDEFINER FunctionInfoSecurityType = "DEFINER"
)

// Defines values for FunctionInfoSqlDataAccess.
const (
	FunctionInfoSqlDataAccessCONTAINSSQL  FunctionInfoSqlDataAccess = "CONTAINS_SQL"
	FunctionInfoSqlDataAccessNOSQL        FunctionInfoSqlDataAccess = "NO_SQL"
	FunctionInfoSqlDataAccessREADSSQLDATA FunctionInfoSqlDataAccess = "READS_SQL_DATA"
)

// Defines values for FunctionParameterMode.
const (
	IN FunctionParameterMode = "IN"
)

// Defines values for FunctionParameterType.
const (
	COLUMN FunctionParameterType = "COLUMN"
	PARAM  FunctionParameterType = "PARAM"
)

// Defines values for ModelVersionOperation.
const (
	READMODELVERSION             ModelVersionOperation = "READ_MODEL_VERSION"
	READWRITEMODELVERSION        ModelVersionOperation = "READ_WRITE_MODEL_VERSION"
	UNKNOWNMODELVERSIONOPERATION ModelVersionOperation = "UNKNOWN_MODEL_VERSION_OPERATION"
)

// Defines values for ModelVersionStatus.
const (
	FAILEDREGISTRATION        ModelVersionStatus = "FAILED_REGISTRATION"
	MODELVERSIONSTATUSUNKNOWN ModelVersionStatus = "MODEL_VERSION_STATUS_UNKNOWN"
	PENDINGREGISTRATION       ModelVersionStatus = "PENDING_REGISTRATION"
	READY                     ModelVersionStatus = "READY"
)

// Defines values for PathOperation.
const (
	PATHCREATETABLE      PathOperation = "PATH_CREATE_TABLE"
	PATHREAD             PathOperation = "PATH_READ"
	PATHREADWRITE        PathOperation = "PATH_READ_WRITE"
	UNKNOWNPATHOPERATION PathOperation = "UNKNOWN_PATH_OPERATION"
)

// Defines values for Privilege.
const (
	PrivilegeCREATECATALOG  Privilege = "CREATE CATALOG"
	PrivilegeCREATEFUNCTION Privilege = "CREATE FUNCTION"
	PrivilegeCREATEMODEL    Privilege = "CREATE MODEL"
	PrivilegeCREATESCHEMA   Privilege = "CREATE SCHEMA"
	PrivilegeCREATETABLE    Privilege = "CREATE TABLE"
	PrivilegeCREATEVOLUME   Privilege = "CREATE VOLUME"
	PrivilegeEXECUTE        Privilege = "EXECUTE"
	PrivilegeREADVOLUME     Privilege = "READ VOLUME"
	PrivilegeSELECT         Privilege = "SELECT"
	PrivilegeUSECATALOG     Privilege = "USE CATALOG"
	PrivilegeUSESCHEMA      Privilege = "USE SCHEMA"
)

// Defines values for SecurableType.
const (
	Catalog         SecurableType = "catalog"
	Function        SecurableType = "function"
	Metastore       SecurableType = "metastore"
	RegisteredModel SecurableType = "registered_model"
	Schema          SecurableType = "schema"
	Table           SecurableType = "table"
	Volume          SecurableType = "volume"
)

// Defines values for TableOperation.
const (
	READ                  TableOperation = "READ"
	READWRITE             TableOperation = "READ_WRITE"
	UNKNOWNTABLEOPERATION TableOperation = "UNKNOWN_TABLE_OPERATION"
)

// Defines values for TableType.
const (
	TableTypeEXTERNAL TableType = "EXTERNAL"
	TableTypeMANAGED  TableType = "MANAGED"
)

// Defines values for VolumeOperation.
const (
	VolumeOperationREADVOLUME             VolumeOperation = "READ_VOLUME"
	VolumeOperationUNKNOWNVOLUMEOPERATION VolumeOperation = "UNKNOWN_VOLUME_OPERATION"
	VolumeOperationWRITEVOLUME            VolumeOperation = "WRITE_VOLUME"
)

// Defines values for VolumeType.
const (
	VolumeTypeEXTERNAL VolumeType = "EXTERNAL"
	VolumeTypeMANAGED  VolumeType = "MANAGED"
)

// AwsCredentials defines model for AwsCredentials.
type AwsCredentials struct {
	// AccessKeyId The access key ID that identifies the temporary credentials.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// SecretAccessKey The secret access key that can be used to sign AWS API requests.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`

	// SessionToken The token that users must pass to AWS API to use the temporary credentials.
	SessionToken *string `json:"session_token,omitempty"`
}

// AzureUserDelegationSAS defines model for AzureUserDelegationSAS.
type AzureUserDelegationSAS struct {
	// SasToken Azure SAS Token
	SasToken *string `json:"sas_token,omitempty"`
}

// CatalogInfo defines model for CatalogInfo.
type CatalogInfo struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this catalog was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy Username of catalog creator.
	CreatedBy *string `json:"created_by,omitempty"`

	// Id Unique identifier for the catalog.
	Id *string `json:"id,omitempty"`

	// Name Name of catalog.
	Name *string `json:"name,omitempty"`

	// Owner Username of current owner of catalog.
	Owner *string `json:"owner,omitempty"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`

	// UpdatedAt Time at which this catalog was last modified, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy Username of user who last modified catalog.
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// ColumnInfo defines model for ColumnInfo.
type ColumnInfo struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// Name Name of Column.
	Name *string `json:"name,omitempty"`

	// Nullable Whether field may be Null.
	Nullable *bool `json:"nullable,omitempty"`

	// PartitionIndex Partition index for column.
	PartitionIndex *int32 `json:"partition_index,omitempty"`

	// Position Ordinal position of column (starting at position 0).
	Position *int32 `json:"position,omitempty"`

	// TypeIntervalType Format of IntervalType.
	TypeIntervalType *string `json:"type_interval_type,omitempty"`

	// TypeJson Full data type specification, JSON-serialized.
	TypeJson *string `json:"type_json,omitempty"`

	// TypeName Name of type (INT, STRUCT, MAP, etc.).
	TypeName *ColumnTypeName `json:"type_name,omitempty"`

	// TypePrecision Digits of precision; required for DecimalTypes.
	TypePrecision *int32 `json:"type_precision,omitempty"`

	// TypeScale Digits to right of decimal; Required for DecimalTypes.
	TypeScale *int32 `json:"type_scale,omitempty"`

	// TypeText Full data type specification as SQL/catalogString text.
	TypeText *string `json:"type_text,omitempty"`
}

// ColumnTypeName Name of type (INT, STRUCT, MAP, etc.).
type ColumnTypeName string

// CreateCatalog defines model for CreateCatalog.
type CreateCatalog struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// Name Name of catalog.
	Name string `json:"name"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`
}

// CreateFunction defines model for CreateFunction.
type CreateFunction struct {
	// CatalogName Name of parent catalog.
	CatalogName string `json:"catalog_name"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// DataType Name of type (INT, STRUCT, MAP, etc.).
	DataType ColumnTypeName `json:"data_type"`

	// ExternalLanguage External language of the function.
	ExternalLanguage *string `json:"external_language,omitempty"`

	// FullDataType Pretty printed function data type.
	FullDataType string                 `json:"full_data_type"`
	InputParams  FunctionParameterInfos `json:"input_params"`

	// IsDeterministic Whether the function is deterministic.
	IsDeterministic bool `json:"is_deterministic"`

	// IsNullCall Function null call.
	IsNullCall bool `json:"is_null_call"`

	// Name Name of function, relative to parent schema.
	Name string `json:"name"`

	// ParameterStyle Function parameter style. **S** is the value for SQL.
	ParameterStyle CreateFunctionParameterStyle `json:"parameter_style"`

	// Properties JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties   string                  `json:"properties"`
	ReturnParams *FunctionParameterInfos `json:"return_params,omitempty"`

	// RoutineBody Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
	// and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
	// and the __sql_data_access__ field must be **NO_SQL**.
	RoutineBody CreateFunctionRoutineBody `json:"routine_body"`

	// RoutineDefinition Function body.
	RoutineDefinition string `json:"routine_definition"`

	// RoutineDependencies A list of dependencies.
	RoutineDependencies *DependencyList `json:"routine_dependencies,omitempty"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName string `json:"schema_name"`

	// SecurityType Function security type.
	SecurityType CreateFunctionSecurityType `json:"security_type"`

	// SpecificName Specific name of the function; Reserved for future use.
	SpecificName string `json:"specific_name"`

	// SqlDataAccess Function SQL data access.
	SqlDataAccess CreateFunctionSqlDataAccess `json:"sql_data_access"`
}

// CreateFunctionParameterStyle Function parameter style. **S** is the value for SQL.
type CreateFunctionParameterStyle string

// CreateFunctionRoutineBody Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
// and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
// and the __sql_data_access__ field must be **NO_SQL**.
type CreateFunctionRoutineBody string

// CreateFunctionSecurityType Function security type.
type CreateFunctionSecurityType string

// CreateFunctionSqlDataAccess Function SQL data access.
type CreateFunctionSqlDataAccess string

// CreateFunctionRequest defines model for CreateFunctionRequest.
type CreateFunctionRequest struct {
	FunctionInfo CreateFunction `json:"function_info"`
}

// CreateModelVersion defines model for CreateModelVersion.
type CreateModelVersion struct {
	// CatalogName Name of parent catalog.
	CatalogName string `json:"catalog_name"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// ModelName Name of registered model, relative to parent schema.
	ModelName string `json:"model_name"`

	// RunId The run id used by the ML package that generated the model.
	RunId *string `json:"run_id,omitempty"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName string `json:"schema_name"`

	// Source URI indicating the location of the source model artifacts.
	Source *string `json:"source,omitempty"`
}

// CreateRegisteredModel defines model for CreateRegisteredModel.
type CreateRegisteredModel struct {
	// CatalogName Name of parent catalog.
	CatalogName string `json:"catalog_name"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// Name Name of model, relative to parent schema.
	Name string `json:"name"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName string `json:"schema_name"`
}

// CreateSchema defines model for CreateSchema.
type CreateSchema struct {
	// CatalogName Name of parent catalog.
	CatalogName string `json:"catalog_name"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// Name Name of schema, relative to parent catalog.
	Name string `json:"name"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`
}

// CreateTable defines model for CreateTable.
type CreateTable struct {
	// CatalogName Name of parent catalog.
	CatalogName string `json:"catalog_name"`

	// Columns The array of __ColumnInfo__ definitions of the table's columns.
	Columns []ColumnInfo `json:"columns"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// DataSourceFormat Data source format
	DataSourceFormat DataSourceFormat `json:"data_source_format"`

	// Name Name of table, relative to parent schema.
	Name string `json:"name"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName string `json:"schema_name"`

	// StorageLocation Storage root URL for external table
	StorageLocation string    `json:"storage_location"`
	TableType       TableType `json:"table_type"`
}

// CreateVolumeRequestContent defines model for CreateVolumeRequestContent.
type CreateVolumeRequestContent struct {
	// CatalogName The name of the catalog where the schema and the volume are
	CatalogName string `json:"catalog_name"`

	// Comment The comment attached to the volume
	Comment *string `json:"comment,omitempty"`

	// Name The name of the volume
	Name string `json:"name"`

	// SchemaName The name of the schema where the volume is
	SchemaName string `json:"schema_name"`

	// StorageLocation The storage location of the volume
	StorageLocation string `json:"storage_location"`

	// VolumeType The type of the volume
	VolumeType VolumeType `json:"volume_type"`
}

// DataSourceFormat Data source format
type DataSourceFormat string

// Dependency A dependency of a SQL object. Either the __table__ field or the __function__ field must be defined.
type Dependency struct {
	// Function A function that is dependent on a SQL object.
	Function *FunctionDependency `json:"function,omitempty"`

	// Table A table that is dependent on a SQL object.
	Table *TableDependency `json:"table,omitempty"`
}

// DependencyList A list of dependencies.
type DependencyList struct {
	// Dependencies Array of dependencies.
	Dependencies *[]Dependency `json:"dependencies,omitempty"`
}

// FinalizeModelVersion defines model for FinalizeModelVersion.
type FinalizeModelVersion struct {
	// FullName The full name of the registered model to finalize.
	FullName string `json:"full_name"`

	// Version Version number of the version to finalize.
	Version int64 `json:"version"`
}

// FunctionDependency A function that is dependent on a SQL object.
type FunctionDependency struct {
	// FunctionFullName Full name of the dependent function, in the form of __catalog_name__.__schema_name__.__function_name__.
	FunctionFullName string `json:"function_full_name"`
}

// FunctionInfo defines model for FunctionInfo.
type FunctionInfo struct {
	// CatalogName Name of parent catalog.
	CatalogName *string `json:"catalog_name,omitempty"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this function was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy Username of function creator.
	CreatedBy *string `json:"created_by,omitempty"`

	// DataType Name of type (INT, STRUCT, MAP, etc.).
	DataType *ColumnTypeName `json:"data_type,omitempty"`

	// ExternalLanguage External language of the function.
	ExternalLanguage *string `json:"external_language,omitempty"`

	// FullDataType Pretty printed function data type.
	FullDataType *string `json:"full_data_type,omitempty"`

	// FullName Full name of function, in form of __catalog_name__.__schema_name__.__function__name__
	FullName *string `json:"full_name,omitempty"`

	// FunctionId Id of Function, relative to parent schema.
	FunctionId  *string                 `json:"function_id,omitempty"`
	InputParams *FunctionParameterInfos `json:"input_params,omitempty"`

	// IsDeterministic Whether the function is deterministic.
	IsDeterministic *bool `json:"is_deterministic,omitempty"`

	// IsNullCall Function null call.
	IsNullCall *bool `json:"is_null_call,omitempty"`

	// Name Name of function, relative to parent schema.
	Name *string `json:"name,omitempty"`

	// Owner Username of current owner of function.
	Owner *string `json:"owner,omitempty"`

	// ParameterStyle Function parameter style. **S** is the value for SQL.
	ParameterStyle *FunctionInfoParameterStyle `json:"parameter_style,omitempty"`

	// Properties JSON-serialized key-value pair map, encoded (escaped) as a string.
	Properties   *string                 `json:"properties,omitempty"`
	ReturnParams *FunctionParameterInfos `json:"return_params,omitempty"`

	// RoutineBody Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
	// and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
	// and the __sql_data_access__ field must be **NO_SQL**.
	RoutineBody *FunctionInfoRoutineBody `json:"routine_body,omitempty"`

	// RoutineDefinition Function body.
	RoutineDefinition *string `json:"routine_definition,omitempty"`

	// RoutineDependencies A list of dependencies.
	RoutineDependencies *DependencyList `json:"routine_dependencies,omitempty"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName *string `json:"schema_name,omitempty"`

	// SecurityType Function security type.
	SecurityType *FunctionInfoSecurityType `json:"security_type,omitempty"`

	// SpecificName Specific name of the function; Reserved for future use.
	SpecificName *string `json:"specific_name,omitempty"`

	// SqlDataAccess Function SQL data access.
	SqlDataAccess *FunctionInfoSqlDataAccess `json:"sql_data_access,omitempty"`

	// UpdatedAt Time at which this function was last updated, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy Username of user who last modified function.
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// FunctionInfoParameterStyle Function parameter style. **S** is the value for SQL.
type FunctionInfoParameterStyle string

// FunctionInfoRoutineBody Function language. When **EXTERNAL** is used, the language of the routine function should be specified in the __external_language__ field,
// and the __return_params__ of the function cannot be used (as **TABLE** return type is not supported),
// and the __sql_data_access__ field must be **NO_SQL**.
type FunctionInfoRoutineBody string

// FunctionInfoSecurityType Function security type.
type FunctionInfoSecurityType string

// FunctionInfoSqlDataAccess Function SQL data access.
type FunctionInfoSqlDataAccess string

// FunctionParameterInfo defines model for FunctionParameterInfo.
type FunctionParameterInfo struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// Name Name of parameter.
	Name string `json:"name"`

	// ParameterDefault Default value of the parameter.
	ParameterDefault *string `json:"parameter_default,omitempty"`

	// ParameterMode The mode of the function parameter.
	ParameterMode *FunctionParameterMode `json:"parameter_mode,omitempty"`

	// ParameterType The type of function parameter.
	ParameterType *FunctionParameterType `json:"parameter_type,omitempty"`

	// Position Ordinal position of column (starting at position 0).
	Position int32 `json:"position"`

	// TypeIntervalType Format of IntervalType.
	TypeIntervalType *string `json:"type_interval_type,omitempty"`

	// TypeJson Full data type spec, JSON-serialized.
	TypeJson string `json:"type_json"`

	// TypeName Name of type (INT, STRUCT, MAP, etc.).
	TypeName ColumnTypeName `json:"type_name"`

	// TypePrecision Digits of precision; required on Create for DecimalTypes.
	TypePrecision *int32 `json:"type_precision,omitempty"`

	// TypeScale Digits to right of decimal; Required on Create for DecimalTypes.
	TypeScale *int32 `json:"type_scale,omitempty"`

	// TypeText Full data type spec, SQL/catalogString text.
	TypeText string `json:"type_text"`
}

// FunctionParameterInfos defines model for FunctionParameterInfos.
type FunctionParameterInfos struct {
	// Parameters The array of __FunctionParameterInfo__ definitions of the function's parameters.
	Parameters *[]FunctionParameterInfo `json:"parameters,omitempty"`
}

// FunctionParameterMode The mode of the function parameter.
type FunctionParameterMode string

// FunctionParameterType The type of function parameter.
type FunctionParameterType string

// GcpOauthToken defines model for GcpOauthToken.
type GcpOauthToken struct {
	// OauthToken Gcp Token
	OauthToken *string `json:"oauth_token,omitempty"`
}

// GenerateTemporaryModelVersionCredential defines model for GenerateTemporaryModelVersionCredential.
type GenerateTemporaryModelVersionCredential struct {
	// CatalogName Catalog name for which temporary credentials are generated.
	// Can be obtained from models/{full_name} (get model info) API.
	CatalogName string `json:"catalog_name"`

	// ModelName Model name for which temporary credentials are generated.
	// Can be obtained from models/{full_name} (get model info) API.
	ModelName string                `json:"model_name"`
	Operation ModelVersionOperation `json:"operation"`

	// SchemaName Schema name for which temporary credentials are generated.
	// Can be obtained from models/{full_name} (get model info) API.
	SchemaName string `json:"schema_name"`

	// Version Model version for which temporary credentials are generated.
	Version int64 `json:"version"`
}

// GenerateTemporaryPathCredential defines model for GenerateTemporaryPathCredential.
type GenerateTemporaryPathCredential struct {
	Operation PathOperation `json:"operation"`

	// Url The URL of the storage path for which temporary credentials need to be generated.
	Url string `json:"url"`
}

// GenerateTemporaryTableCredential defines model for GenerateTemporaryTableCredential.
type GenerateTemporaryTableCredential struct {
	Operation TableOperation `json:"operation"`

	// TableId Table id for which temporary credentials are generated.
	// Can be obtained from tables/{full_name} (get table info) API.
	TableId string `json:"table_id"`
}

// GenerateTemporaryVolumeCredential defines model for GenerateTemporaryVolumeCredential.
type GenerateTemporaryVolumeCredential struct {
	Operation VolumeOperation `json:"operation"`

	// VolumeId Volume id for which temporary credentials are generated.
	// Can be obtained from volumes/{full_name} (get volume info) API.
	VolumeId string `json:"volume_id"`
}

// ListCatalogsResponse defines model for ListCatalogsResponse.
type ListCatalogsResponse struct {
	// Catalogs An array of catalog information objects.
	Catalogs *[]CatalogInfo `json:"catalogs,omitempty"`

	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// ListFunctionsResponse defines model for ListFunctionsResponse.
type ListFunctionsResponse struct {
	// Functions An array of function information objects.
	Functions *[]FunctionInfo `json:"functions,omitempty"`

	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// ListModelVersionsResponse defines model for ListModelVersionsResponse.
type ListModelVersionsResponse struct {
	// ModelVersions An array of model version information objects.
	ModelVersions *[]ModelVersionInfo `json:"model_versions,omitempty"`

	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`
}

// ListRegisteredModelsResponse defines model for ListRegisteredModelsResponse.
type ListRegisteredModelsResponse struct {
	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`

	// RegisteredModels An array of model information objects.
	RegisteredModels *[]RegisteredModelInfo `json:"registered_models,omitempty"`
}

// ListSchemasResponse defines model for ListSchemasResponse.
type ListSchemasResponse struct {
	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`

	// Schemas An array of schema information objects.
	Schemas *[]SchemaInfo `json:"schemas,omitempty"`
}

// ListTablesResponse defines model for ListTablesResponse.
type ListTablesResponse struct {
	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request (for the next page of results).
	NextPageToken *string `json:"next_page_token,omitempty"`

	// Tables An array of table information objects.
	Tables *[]TableInfo `json:"tables,omitempty"`
}

// ListVolumesResponseContent defines model for ListVolumesResponseContent.
type ListVolumesResponseContent struct {
	// NextPageToken Opaque token to retrieve the next page of results. Absent if there are no more pages.
	// __page_token__ should be set to this value for the next request to retrieve the next page of results.
	NextPageToken *string       `json:"next_page_token,omitempty"`
	Volumes       *[]VolumeInfo `json:"volumes,omitempty"`
}

// ModelVersionInfo defines model for ModelVersionInfo.
type ModelVersionInfo struct {
	// CatalogName The name of the catalog containing the model version
	CatalogName *string `json:"catalog_name,omitempty"`

	// Comment The comment attached to the model version
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this model version was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy The identifier of the user who created the model version
	CreatedBy *string `json:"created_by,omitempty"`

	// Id Unique identifier for the model version.
	Id *string `json:"id,omitempty"`

	// ModelName The name of the parent registered model of the model version, relative to parent schema
	ModelName *string `json:"model_name,omitempty"`

	// RunId The run id used by the ML package that generated the model.
	RunId *string `json:"run_id,omitempty"`

	// SchemaName The name of the schema containing the model version, relative to parent catalog
	SchemaName *string `json:"schema_name,omitempty"`

	// Source URI indicating the location of the source artifacts (files) for the model version
	Source *string `json:"source,omitempty"`

	// Status All possible model version statuses (MODEL_VERSION_STATUS_UNKNOWN, PENDING_REGISTRATION, FAILED_REGISTRATION, READY).
	// PENDING_REGISTRATION status indicates that the client has not completely written all model artifacts to external storage.
	// FAILED_REGISTRATION status indicates that the client has failed to write all model artifacts to external storage.
	// READY status indicates that the client has successfully written all model artifacts to external storage.
	Status *ModelVersionStatus `json:"status,omitempty"`

	// StorageLocation The storage location on the cloud under which model version data files are stored
	StorageLocation *string `json:"storage_location,omitempty"`

	// UpdatedAt Time at which this model version was last modified, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy The identifier of the user who updated the model version last time
	UpdatedBy *string `json:"updated_by,omitempty"`

	// Version Integer model version number, used to reference the model version in API requests.
	Version *int64 `json:"version,omitempty"`
}

// ModelVersionOperation defines model for ModelVersionOperation.
type ModelVersionOperation string

// ModelVersionStatus All possible model version statuses (MODEL_VERSION_STATUS_UNKNOWN, PENDING_REGISTRATION, FAILED_REGISTRATION, READY).
// PENDING_REGISTRATION status indicates that the client has not completely written all model artifacts to external storage.
// FAILED_REGISTRATION status indicates that the client has failed to write all model artifacts to external storage.
// READY status indicates that the client has successfully written all model artifacts to external storage.
type ModelVersionStatus string

// PathOperation defines model for PathOperation.
type PathOperation string

// PermissionsChange defines model for PermissionsChange.
type PermissionsChange struct {
	// Add The set of privileges to add.
	Add []Privilege `json:"add"`

	// Principal The principal whose privileges we are changing.
	Principal string `json:"principal"`

	// Remove The set of privileges to remove.
	Remove []Privilege `json:"remove"`
}

// PermissionsList defines model for PermissionsList.
type PermissionsList struct {
	// PrivilegeAssignments The privileges assigned to each principal.
	PrivilegeAssignments []PrivilegeAssignment `json:"privilege_assignments"`
}

// Privilege The privilege to grant.
type Privilege string

// PrivilegeAssignment defines model for PrivilegeAssignment.
type PrivilegeAssignment struct {
	// Principal The principal (user email address or group name).
	Principal string `json:"principal"`

	// Privileges The privileges assigned to the principal.
	Privileges []Privilege `json:"privileges"`
}

// RegisteredModelInfo defines model for RegisteredModelInfo.
type RegisteredModelInfo struct {
	// CatalogName The name of the catalog where the schema and the registered model reside
	CatalogName *string `json:"catalog_name,omitempty"`

	// Comment The comment attached to the registered model
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Creation timestamp of the registered model in milliseconds since the Unix epoch
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy The identifier of the user who created the registered model
	CreatedBy *string `json:"created_by,omitempty"`

	// FullName The three-level (fully qualified) name of the registered model
	FullName *string `json:"full_name,omitempty"`

	// Id Unique identifier for the registered model.
	Id *string `json:"id,omitempty"`

	// Name The name of the registered model
	Name *string `json:"name,omitempty"`

	// Owner The identifier of the user who owns the registered model
	Owner *string `json:"owner,omitempty"`

	// SchemaName The name of the schema where the registered model resides
	SchemaName *string `json:"schema_name,omitempty"`

	// StorageLocation The storage location on the cloud under which model version data files are stored
	StorageLocation *string `json:"storage_location,omitempty"`

	// UpdatedAt Last-update timestamp of the registered model in milliseconds since the Unix epoch
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy The identifier of the user who updated the registered model last time
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// SchemaInfo defines model for SchemaInfo.
type SchemaInfo struct {
	// CatalogName Name of parent catalog.
	CatalogName *string `json:"catalog_name,omitempty"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this schema was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy Username of schema creator.
	CreatedBy *string `json:"created_by,omitempty"`

	// FullName Full name of schema, in form of __catalog_name__.__schema_name__.
	FullName *string `json:"full_name,omitempty"`

	// Name Name of schema, relative to parent catalog.
	Name *string `json:"name,omitempty"`

	// Owner Username of current owner of schema.
	Owner *string `json:"owner,omitempty"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`

	// SchemaId Unique identifier for the schema.
	SchemaId *string `json:"schema_id,omitempty"`

	// UpdatedAt Time at which this schema was last modified, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy Username of user who last modified schema.
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// SecurablePropertiesMap A map of key-value properties attached to the securable.
type SecurablePropertiesMap map[string]string

// SecurableType The type of the resource.
type SecurableType string

// TableDependency A table that is dependent on a SQL object.
type TableDependency struct {
	// TableFullName Full name of the dependent table, in the form of __catalog_name__.__schema_name__.__table_name__.
	TableFullName string `json:"table_full_name"`
}

// TableInfo defines model for TableInfo.
type TableInfo struct {
	// CatalogName Name of parent catalog.
	CatalogName *string `json:"catalog_name,omitempty"`

	// Columns The array of __ColumnInfo__ definitions of the table's columns.
	Columns *[]ColumnInfo `json:"columns,omitempty"`

	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this table was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy Username of table creator.
	CreatedBy *string `json:"created_by,omitempty"`

	// DataSourceFormat Data source format
	DataSourceFormat *DataSourceFormat `json:"data_source_format,omitempty"`

	// Name Name of table, relative to parent schema.
	Name *string `json:"name,omitempty"`

	// Owner Username of current owner of table.
	Owner *string `json:"owner,omitempty"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`

	// SchemaName Name of parent schema relative to its parent catalog.
	SchemaName *string `json:"schema_name,omitempty"`

	// StorageLocation Storage root URL for table (for **MANAGED**, **EXTERNAL** tables)
	StorageLocation *string `json:"storage_location,omitempty"`

	// TableId Unique identifier for the table.
	TableId   *string    `json:"table_id,omitempty"`
	TableType *TableType `json:"table_type,omitempty"`

	// UpdatedAt Time at which this table was last modified, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy Username of user who last modified the table.
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// TableOperation defines model for TableOperation.
type TableOperation string

// TableType defines model for TableType.
type TableType string

// TemporaryCredentials defines model for TemporaryCredentials.
type TemporaryCredentials struct {
	AwsTempCredentials     *AwsCredentials         `json:"aws_temp_credentials,omitempty"`
	AzureUserDelegationSas *AzureUserDelegationSAS `json:"azure_user_delegation_sas,omitempty"`

	// ExpirationTime Server time when the credential will expire, in epoch milliseconds.
	// The API client is advised to cache the credential given this expiration time.
	ExpirationTime *int64         `json:"expiration_time,omitempty"`
	GcpOauthToken  *GcpOauthToken `json:"gcp_oauth_token,omitempty"`
}

// UpdateCatalog defines model for UpdateCatalog.
type UpdateCatalog struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// NewName New name for the catalog.
	NewName *string `json:"new_name,omitempty"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`
}

// UpdateModelVersion defines model for UpdateModelVersion.
type UpdateModelVersion struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// FullName The full name of the registered model to update.
	FullName *string `json:"full_name,omitempty"`

	// Version Version number of the version to update.
	Version *int64 `json:"version,omitempty"`
}

// UpdatePermissions defines model for UpdatePermissions.
type UpdatePermissions struct {
	// Changes Array of permissions change objects.
	Changes []PermissionsChange `json:"changes"`
}

// UpdateRegisteredModel defines model for UpdateRegisteredModel.
type UpdateRegisteredModel struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// FullName The full name of the registered model to update.
	FullName *string `json:"full_name,omitempty"`

	// NewName New name for the model.
	NewName *string `json:"new_name,omitempty"`
}

// UpdateSchema defines model for UpdateSchema.
type UpdateSchema struct {
	// Comment User-provided free-form text description.
	Comment *string `json:"comment,omitempty"`

	// NewName New name for the schema.
	NewName *string `json:"new_name,omitempty"`

	// Properties A map of key-value properties attached to the securable.
	Properties *SecurablePropertiesMap `json:"properties,omitempty"`
}

// UpdateVolumeRequestContent defines model for UpdateVolumeRequestContent.
type UpdateVolumeRequestContent struct {
	// Comment The comment attached to the volume
	Comment *string `json:"comment,omitempty"`

	// NewName New name for the volume.
	NewName *string `json:"new_name,omitempty"`
}

// VolumeInfo defines model for VolumeInfo.
type VolumeInfo struct {
	// CatalogName The name of the catalog where the schema and the volume are
	CatalogName *string `json:"catalog_name,omitempty"`

	// Comment The comment attached to the volume
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Time at which this volume was created, in epoch milliseconds.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy TThe identifier of the user who created the volume
	CreatedBy *string `json:"created_by,omitempty"`

	// FullName Full name of volume, in form of __catalog_name__.__schema_name__.__volume_name__.
	FullName *string `json:"full_name,omitempty"`

	// Name The name of the volume
	Name *string `json:"name,omitempty"`

	// Owner The identifier of the user who owns the volume
	Owner *string `json:"owner,omitempty"`

	// SchemaName The name of the schema where the volume is
	SchemaName *string `json:"schema_name,omitempty"`

	// StorageLocation The storage location of the volume
	StorageLocation *string `json:"storage_location,omitempty"`

	// UpdatedAt Time at which this volume was last modified, in epoch milliseconds.
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy The identifier of the user who updated the volume last time
	UpdatedBy *string `json:"updated_by,omitempty"`

	// VolumeId Unique identifier of the volume
	VolumeId *string `json:"volume_id,omitempty"`

	// VolumeType The type of the volume
	VolumeType *VolumeType `json:"volume_type,omitempty"`
}

// VolumeOperation defines model for VolumeOperation.
type VolumeOperation string

// VolumeType The type of the volume
type VolumeType string

// ListCatalogsParams defines parameters for ListCatalogs.
type ListCatalogsParams struct {
	// PageToken Opaque pagination token to go to next page based on previous query.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`

	// MaxResults Maximum number of catalogs to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`
}

// DeleteCatalogParams defines parameters for DeleteCatalog.
type DeleteCatalogParams struct {
	// Force Force deletion even if the catalog is not empty.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// ListFunctionsParams defines parameters for ListFunctions.
type ListFunctionsParams struct {
	// CatalogName Name of parent catalog for functions of interest.
	CatalogName string `form:"catalog_name" json:"catalog_name"`

	// SchemaName Parent schema of functions.
	SchemaName string `form:"schema_name" json:"schema_name"`

	// MaxResults Maximum number of functions to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque pagination token to go to next page based on previous query.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// ListRegisteredModelsParams defines parameters for ListRegisteredModels.
type ListRegisteredModelsParams struct {
	// CatalogName Name of parent catalog for models of interest.
	CatalogName *string `form:"catalog_name,omitempty" json:"catalog_name,omitempty"`

	// SchemaName Name of parent schema for models of interest.
	SchemaName *string `form:"schema_name,omitempty" json:"schema_name,omitempty"`

	// MaxResults Maximum number of models to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque token to send for the next page of results (pagination).
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// DeleteRegisteredModelParams defines parameters for DeleteRegisteredModel.
type DeleteRegisteredModelParams struct {
	// Force Force deletion even if the registered model still has model versions.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// ListModelVersionsParams defines parameters for ListModelVersions.
type ListModelVersionsParams struct {
	// MaxResults Maximum number of model versions to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque token to send for the next page of results (pagination).
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// GetParams defines parameters for Get.
type GetParams struct {
	// Principal If provided, only the permissions for the specified principal (user or group) are returned.
	Principal *string `form:"principal,omitempty" json:"principal,omitempty"`
}

// ListSchemasParams defines parameters for ListSchemas.
type ListSchemasParams struct {
	// CatalogName Parent catalog for schemas of interest.
	CatalogName string `form:"catalog_name" json:"catalog_name"`

	// MaxResults Maximum number of schemas to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque pagination token to go to next page based on previous query.
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// DeleteSchemaParams defines parameters for DeleteSchema.
type DeleteSchemaParams struct {
	// Force Force deletion even if the catalog is not empty.
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {
	// CatalogName Name of parent catalog for tables of interest.
	CatalogName string `form:"catalog_name" json:"catalog_name"`

	// SchemaName Parent schema of tables.
	SchemaName string `form:"schema_name" json:"schema_name"`

	// MaxResults Maximum number of tables to return.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque token to send for the next page of results (pagination).
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// ListVolumesParams defines parameters for ListVolumes.
type ListVolumesParams struct {
	// CatalogName The identifier of the catalog
	CatalogName string `form:"catalog_name" json:"catalog_name"`

	// SchemaName The identifier of the schema
	SchemaName string `form:"schema_name" json:"schema_name"`

	// MaxResults Maximum number of volumes to return (page length).
	//
	// If not set, the page length is set to a server configured value.
	// - when set to a value greater than 0, the page length is the minimum of this value and a server configured value;
	// - when set to 0, the page length is set to a server configured value;
	// - when set to a value less than 0, an invalid parameter error is returned;
	//
	// Note: this parameter controls only the maximum number of volumes to return. The actual number of volumes returned in a page may be smaller than this value, including 0, even if there are more pages.
	//
	MaxResults *int32 `form:"max_results,omitempty" json:"max_results,omitempty"`

	// PageToken Opaque token returned by a previous request. It must be included in the request to retrieve the next page of results (pagination).
	PageToken *string `form:"page_token,omitempty" json:"page_token,omitempty"`
}

// CreateCatalogJSONRequestBody defines body for CreateCatalog for application/json ContentType.
type CreateCatalogJSONRequestBody = CreateCatalog

// UpdateCatalogJSONRequestBody defines body for UpdateCatalog for application/json ContentType.
type UpdateCatalogJSONRequestBody = UpdateCatalog

// CreateFunctionJSONRequestBody defines body for CreateFunction for application/json ContentType.
type CreateFunctionJSONRequestBody = CreateFunctionRequest

// CreateRegisteredModelJSONRequestBody defines body for CreateRegisteredModel for application/json ContentType.
type CreateRegisteredModelJSONRequestBody = CreateRegisteredModel

// CreateModelVersionJSONRequestBody defines body for CreateModelVersion for application/json ContentType.
type CreateModelVersionJSONRequestBody = CreateModelVersion

// UpdateRegisteredModelJSONRequestBody defines body for UpdateRegisteredModel for application/json ContentType.
type UpdateRegisteredModelJSONRequestBody = UpdateRegisteredModel

// UpdateModelVersionJSONRequestBody defines body for UpdateModelVersion for application/json ContentType.
type UpdateModelVersionJSONRequestBody = UpdateModelVersion

// FinalizeModelVersionJSONRequestBody defines body for FinalizeModelVersion for application/json ContentType.
type FinalizeModelVersionJSONRequestBody = FinalizeModelVersion

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody = UpdatePermissions

// CreateSchemaJSONRequestBody defines body for CreateSchema for application/json ContentType.
type CreateSchemaJSONRequestBody = CreateSchema

// UpdateSchemaJSONRequestBody defines body for UpdateSchema for application/json ContentType.
type UpdateSchemaJSONRequestBody = UpdateSchema

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = CreateTable

// GenerateTemporaryModelVersionCredentialsJSONRequestBody defines body for GenerateTemporaryModelVersionCredentials for application/json ContentType.
type GenerateTemporaryModelVersionCredentialsJSONRequestBody = GenerateTemporaryModelVersionCredential

// GenerateTemporaryPathCredentialsJSONRequestBody defines body for GenerateTemporaryPathCredentials for application/json ContentType.
type GenerateTemporaryPathCredentialsJSONRequestBody = GenerateTemporaryPathCredential

// GenerateTemporaryTableCredentialsJSONRequestBody defines body for GenerateTemporaryTableCredentials for application/json ContentType.
type GenerateTemporaryTableCredentialsJSONRequestBody = GenerateTemporaryTableCredential

// GenerateTemporaryVolumeCredentialsJSONRequestBody defines body for GenerateTemporaryVolumeCredentials for application/json ContentType.
type GenerateTemporaryVolumeCredentialsJSONRequestBody = GenerateTemporaryVolumeCredential

// CreateVolumeJSONRequestBody defines body for CreateVolume for application/json ContentType.
type CreateVolumeJSONRequestBody = CreateVolumeRequestContent

// UpdateVolumeJSONRequestBody defines body for UpdateVolume for application/json ContentType.
type UpdateVolumeJSONRequestBody = UpdateVolumeRequestContent

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCatalogs request
	ListCatalogs(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCatalogWithBody request with any body
	CreateCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCatalog(ctx context.Context, body CreateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCatalog request
	DeleteCatalog(ctx context.Context, name string, params *DeleteCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCatalog request
	GetCatalog(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCatalogWithBody request with any body
	UpdateCatalogWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCatalog(ctx context.Context, name string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFunctions request
	ListFunctions(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionWithBody request with any body
	CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFunction request
	DeleteFunction(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFunction request
	GetFunction(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegisteredModels request
	ListRegisteredModels(ctx context.Context, params *ListRegisteredModelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRegisteredModelWithBody request with any body
	CreateRegisteredModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRegisteredModel(ctx context.Context, body CreateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModelVersionWithBody request with any body
	CreateModelVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateModelVersion(ctx context.Context, body CreateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRegisteredModel request
	DeleteRegisteredModel(ctx context.Context, fullName string, params *DeleteRegisteredModelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegisteredModel request
	GetRegisteredModel(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRegisteredModelWithBody request with any body
	UpdateRegisteredModelWithBody(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRegisteredModel(ctx context.Context, fullName string, body UpdateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModelVersions request
	ListModelVersions(ctx context.Context, fullName string, params *ListModelVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModelVersion request
	DeleteModelVersion(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModelVersion request
	GetModelVersion(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModelVersionWithBody request with any body
	UpdateModelVersionWithBody(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateModelVersion(ctx context.Context, fullName string, version int64, body UpdateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FinalizeModelVersionWithBody request with any body
	FinalizeModelVersionWithBody(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FinalizeModelVersion(ctx context.Context, fullName string, version int64, body FinalizeModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Get request
	Get(ctx context.Context, securableType SecurableType, fullName string, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWithBody request with any body
	UpdateWithBody(ctx context.Context, securableType SecurableType, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update(ctx context.Context, securableType SecurableType, fullName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchemas request
	ListSchemas(ctx context.Context, params *ListSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchemaWithBody request with any body
	CreateSchemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchema(ctx context.Context, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSchema request
	DeleteSchema(ctx context.Context, fullName string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchema request
	GetSchema(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchemaWithBody request with any body
	UpdateSchemaWithBody(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchema(ctx context.Context, fullName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTemporaryModelVersionCredentialsWithBody request with any body
	GenerateTemporaryModelVersionCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTemporaryModelVersionCredentials(ctx context.Context, body GenerateTemporaryModelVersionCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTemporaryPathCredentialsWithBody request with any body
	GenerateTemporaryPathCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTemporaryPathCredentials(ctx context.Context, body GenerateTemporaryPathCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTemporaryTableCredentialsWithBody request with any body
	GenerateTemporaryTableCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTemporaryTableCredentials(ctx context.Context, body GenerateTemporaryTableCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTemporaryVolumeCredentialsWithBody request with any body
	GenerateTemporaryVolumeCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTemporaryVolumeCredentials(ctx context.Context, body GenerateTemporaryVolumeCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVolumes request
	ListVolumes(ctx context.Context, params *ListVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeWithBody request with any body
	CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVolume request
	DeleteVolume(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVolume request
	GetVolume(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVolumeWithBody request with any body
	UpdateVolumeWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVolume(ctx context.Context, name string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCatalogs(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCatalogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCatalogWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCatalog(ctx context.Context, body CreateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCatalogRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCatalog(ctx context.Context, name string, params *DeleteCatalogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCatalogRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCatalog(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCatalogRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalogWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCatalog(ctx context.Context, name string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCatalogRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFunctions(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFunctionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunction(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFunction(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFunctionRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFunction(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFunctionRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegisteredModels(ctx context.Context, params *ListRegisteredModelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegisteredModelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRegisteredModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRegisteredModelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRegisteredModel(ctx context.Context, body CreateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRegisteredModelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModelVersion(ctx context.Context, body CreateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModelVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRegisteredModel(ctx context.Context, fullName string, params *DeleteRegisteredModelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRegisteredModelRequest(c.Server, fullName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegisteredModel(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegisteredModelRequest(c.Server, fullName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegisteredModelWithBody(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegisteredModelRequestWithBody(c.Server, fullName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRegisteredModel(ctx context.Context, fullName string, body UpdateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRegisteredModelRequest(c.Server, fullName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModelVersions(ctx context.Context, fullName string, params *ListModelVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModelVersionsRequest(c.Server, fullName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModelVersion(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModelVersionRequest(c.Server, fullName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModelVersion(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelVersionRequest(c.Server, fullName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModelVersionWithBody(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelVersionRequestWithBody(c.Server, fullName, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModelVersion(ctx context.Context, fullName string, version int64, body UpdateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModelVersionRequest(c.Server, fullName, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FinalizeModelVersionWithBody(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFinalizeModelVersionRequestWithBody(c.Server, fullName, version, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FinalizeModelVersion(ctx context.Context, fullName string, version int64, body FinalizeModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFinalizeModelVersionRequest(c.Server, fullName, version, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Get(ctx context.Context, securableType SecurableType, fullName string, params *GetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequest(c.Server, securableType, fullName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWithBody(ctx context.Context, securableType SecurableType, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(c.Server, securableType, fullName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update(ctx context.Context, securableType SecurableType, fullName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(c.Server, securableType, fullName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchemas(ctx context.Context, params *ListSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchemaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchema(ctx context.Context, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchemaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSchema(ctx context.Context, fullName string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSchemaRequest(c.Server, fullName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchema(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchemaRequest(c.Server, fullName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchemaWithBody(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequestWithBody(c.Server, fullName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchema(ctx context.Context, fullName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSchemaRequest(c.Server, fullName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, fullName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, fullName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryModelVersionCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryModelVersionCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryModelVersionCredentials(ctx context.Context, body GenerateTemporaryModelVersionCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryModelVersionCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryPathCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryPathCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryPathCredentials(ctx context.Context, body GenerateTemporaryPathCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryPathCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryTableCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryTableCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryTableCredentials(ctx context.Context, body GenerateTemporaryTableCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryTableCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryVolumeCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryVolumeCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTemporaryVolumeCredentials(ctx context.Context, body GenerateTemporaryVolumeCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTemporaryVolumeCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVolumes(ctx context.Context, params *ListVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVolumesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolume(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVolume(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVolumeRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVolume(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVolumeRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolumeWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVolume(ctx context.Context, name string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVolumeRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCatalogsRequest generates requests for ListCatalogs
func NewListCatalogsRequest(server string, params *ListCatalogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCatalogRequest calls the generic CreateCatalog builder with application/json body
func NewCreateCatalogRequest(server string, body CreateCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCatalogRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCatalogRequestWithBody generates requests for CreateCatalog with any type of body
func NewCreateCatalogRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCatalogRequest generates requests for DeleteCatalog
func NewDeleteCatalogRequest(server string, name string, params *DeleteCatalogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCatalogRequest generates requests for GetCatalog
func NewGetCatalogRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCatalogRequest calls the generic UpdateCatalog builder with application/json body
func NewUpdateCatalogRequest(server string, name string, body UpdateCatalogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCatalogRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateCatalogRequestWithBody generates requests for UpdateCatalog with any type of body
func NewUpdateCatalogRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/catalogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFunctionsRequest generates requests for ListFunctions
func NewListFunctionsRequest(server string, params *ListFunctionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_name", runtime.ParamLocationQuery, params.CatalogName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema_name", runtime.ParamLocationQuery, params.SchemaName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFunctionRequest calls the generic CreateFunction builder with application/json body
func NewCreateFunctionRequest(server string, body CreateFunctionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFunctionRequestWithBody generates requests for CreateFunction with any type of body
func NewCreateFunctionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFunctionRequest generates requests for DeleteFunction
func NewDeleteFunctionRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFunctionRequest generates requests for GetFunction
func NewGetFunctionRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegisteredModelsRequest generates requests for ListRegisteredModels
func NewListRegisteredModelsRequest(server string, params *ListRegisteredModelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CatalogName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_name", runtime.ParamLocationQuery, *params.CatalogName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema_name", runtime.ParamLocationQuery, *params.SchemaName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRegisteredModelRequest calls the generic CreateRegisteredModel builder with application/json body
func NewCreateRegisteredModelRequest(server string, body CreateRegisteredModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRegisteredModelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRegisteredModelRequestWithBody generates requests for CreateRegisteredModel with any type of body
func NewCreateRegisteredModelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateModelVersionRequest calls the generic CreateModelVersion builder with application/json body
func NewCreateModelVersionRequest(server string, body CreateModelVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModelVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModelVersionRequestWithBody generates requests for CreateModelVersion with any type of body
func NewCreateModelVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/versions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRegisteredModelRequest generates requests for DeleteRegisteredModel
func NewDeleteRegisteredModelRequest(server string, fullName string, params *DeleteRegisteredModelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegisteredModelRequest generates requests for GetRegisteredModel
func NewGetRegisteredModelRequest(server string, fullName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRegisteredModelRequest calls the generic UpdateRegisteredModel builder with application/json body
func NewUpdateRegisteredModelRequest(server string, fullName string, body UpdateRegisteredModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRegisteredModelRequestWithBody(server, fullName, "application/json", bodyReader)
}

// NewUpdateRegisteredModelRequestWithBody generates requests for UpdateRegisteredModel with any type of body
func NewUpdateRegisteredModelRequestWithBody(server string, fullName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModelVersionsRequest generates requests for ListModelVersions
func NewListModelVersionsRequest(server string, fullName string, params *ListModelVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteModelVersionRequest generates requests for DeleteModelVersion
func NewDeleteModelVersionRequest(server string, fullName string, version int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModelVersionRequest generates requests for GetModelVersion
func NewGetModelVersionRequest(server string, fullName string, version int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModelVersionRequest calls the generic UpdateModelVersion builder with application/json body
func NewUpdateModelVersionRequest(server string, fullName string, version int64, body UpdateModelVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModelVersionRequestWithBody(server, fullName, version, "application/json", bodyReader)
}

// NewUpdateModelVersionRequestWithBody generates requests for UpdateModelVersion with any type of body
func NewUpdateModelVersionRequestWithBody(server string, fullName string, version int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFinalizeModelVersionRequest calls the generic FinalizeModelVersion builder with application/json body
func NewFinalizeModelVersionRequest(server string, fullName string, version int64, body FinalizeModelVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFinalizeModelVersionRequestWithBody(server, fullName, version, "application/json", bodyReader)
}

// NewFinalizeModelVersionRequestWithBody generates requests for FinalizeModelVersion with any type of body
func NewFinalizeModelVersionRequestWithBody(server string, fullName string, version int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models/%s/versions/%s/finalize", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRequest generates requests for Get
func NewGetRequest(server string, securableType SecurableType, fullName string, params *GetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "securable_type", runtime.ParamLocationPath, securableType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Principal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "principal", runtime.ParamLocationQuery, *params.Principal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(server string, securableType SecurableType, fullName string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(server, securableType, fullName, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(server string, securableType SecurableType, fullName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "securable_type", runtime.ParamLocationPath, securableType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSchemasRequest generates requests for ListSchemas
func NewListSchemasRequest(server string, params *ListSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_name", runtime.ParamLocationQuery, params.CatalogName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSchemaRequest calls the generic CreateSchema builder with application/json body
func NewCreateSchemaRequest(server string, body CreateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSchemaRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSchemaRequestWithBody generates requests for CreateSchema with any type of body
func NewCreateSchemaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSchemaRequest generates requests for DeleteSchema
func NewDeleteSchemaRequest(server string, fullName string, params *DeleteSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchemaRequest generates requests for GetSchema
func NewGetSchemaRequest(server string, fullName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSchemaRequest calls the generic UpdateSchema builder with application/json body
func NewUpdateSchemaRequest(server string, fullName string, body UpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSchemaRequestWithBody(server, fullName, "application/json", bodyReader)
}

// NewUpdateSchemaRequestWithBody generates requests for UpdateSchema with any type of body
func NewUpdateSchemaRequestWithBody(server string, fullName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, params *ListTablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_name", runtime.ParamLocationQuery, params.CatalogName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema_name", runtime.ParamLocationQuery, params.SchemaName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, fullName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, fullName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "full_name", runtime.ParamLocationPath, fullName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTemporaryModelVersionCredentialsRequest calls the generic GenerateTemporaryModelVersionCredentials builder with application/json body
func NewGenerateTemporaryModelVersionCredentialsRequest(server string, body GenerateTemporaryModelVersionCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTemporaryModelVersionCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTemporaryModelVersionCredentialsRequestWithBody generates requests for GenerateTemporaryModelVersionCredentials with any type of body
func NewGenerateTemporaryModelVersionCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/temporary-model-version-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateTemporaryPathCredentialsRequest calls the generic GenerateTemporaryPathCredentials builder with application/json body
func NewGenerateTemporaryPathCredentialsRequest(server string, body GenerateTemporaryPathCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTemporaryPathCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTemporaryPathCredentialsRequestWithBody generates requests for GenerateTemporaryPathCredentials with any type of body
func NewGenerateTemporaryPathCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/temporary-path-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateTemporaryTableCredentialsRequest calls the generic GenerateTemporaryTableCredentials builder with application/json body
func NewGenerateTemporaryTableCredentialsRequest(server string, body GenerateTemporaryTableCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTemporaryTableCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTemporaryTableCredentialsRequestWithBody generates requests for GenerateTemporaryTableCredentials with any type of body
func NewGenerateTemporaryTableCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/temporary-table-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateTemporaryVolumeCredentialsRequest calls the generic GenerateTemporaryVolumeCredentials builder with application/json body
func NewGenerateTemporaryVolumeCredentialsRequest(server string, body GenerateTemporaryVolumeCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateTemporaryVolumeCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewGenerateTemporaryVolumeCredentialsRequestWithBody generates requests for GenerateTemporaryVolumeCredentials with any type of body
func NewGenerateTemporaryVolumeCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/temporary-volume-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVolumesRequest generates requests for ListVolumes
func NewListVolumesRequest(server string, params *ListVolumesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "catalog_name", runtime.ParamLocationQuery, params.CatalogName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema_name", runtime.ParamLocationQuery, params.SchemaName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MaxResults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_results", runtime.ParamLocationQuery, *params.MaxResults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_token", runtime.ParamLocationQuery, *params.PageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeRequest calls the generic CreateVolume builder with application/json body
func NewCreateVolumeRequest(server string, body CreateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVolumeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateVolumeRequestWithBody generates requests for CreateVolume with any type of body
func NewCreateVolumeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVolumeRequest generates requests for DeleteVolume
func NewDeleteVolumeRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVolumeRequest generates requests for GetVolume
func NewGetVolumeRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVolumeRequest calls the generic UpdateVolume builder with application/json body
func NewUpdateVolumeRequest(server string, name string, body UpdateVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVolumeRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateVolumeRequestWithBody generates requests for UpdateVolume with any type of body
func NewUpdateVolumeRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCatalogsWithResponse request
	ListCatalogsWithResponse(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*ListCatalogsResp, error)

	// CreateCatalogWithBodyWithResponse request with any body
	CreateCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCatalogResp, error)

	CreateCatalogWithResponse(ctx context.Context, body CreateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCatalogResp, error)

	// DeleteCatalogWithResponse request
	DeleteCatalogWithResponse(ctx context.Context, name string, params *DeleteCatalogParams, reqEditors ...RequestEditorFn) (*DeleteCatalogResp, error)

	// GetCatalogWithResponse request
	GetCatalogWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCatalogResp, error)

	// UpdateCatalogWithBodyWithResponse request with any body
	UpdateCatalogWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResp, error)

	UpdateCatalogWithResponse(ctx context.Context, name string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResp, error)

	// ListFunctionsWithResponse request
	ListFunctionsWithResponse(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*ListFunctionsResp, error)

	// CreateFunctionWithBodyWithResponse request with any body
	CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResp, error)

	CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResp, error)

	// DeleteFunctionWithResponse request
	DeleteFunctionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteFunctionResp, error)

	// GetFunctionWithResponse request
	GetFunctionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetFunctionResp, error)

	// ListRegisteredModelsWithResponse request
	ListRegisteredModelsWithResponse(ctx context.Context, params *ListRegisteredModelsParams, reqEditors ...RequestEditorFn) (*ListRegisteredModelsResp, error)

	// CreateRegisteredModelWithBodyWithResponse request with any body
	CreateRegisteredModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRegisteredModelResp, error)

	CreateRegisteredModelWithResponse(ctx context.Context, body CreateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRegisteredModelResp, error)

	// CreateModelVersionWithBodyWithResponse request with any body
	CreateModelVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelVersionResp, error)

	CreateModelVersionWithResponse(ctx context.Context, body CreateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelVersionResp, error)

	// DeleteRegisteredModelWithResponse request
	DeleteRegisteredModelWithResponse(ctx context.Context, fullName string, params *DeleteRegisteredModelParams, reqEditors ...RequestEditorFn) (*DeleteRegisteredModelResp, error)

	// GetRegisteredModelWithResponse request
	GetRegisteredModelWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetRegisteredModelResp, error)

	// UpdateRegisteredModelWithBodyWithResponse request with any body
	UpdateRegisteredModelWithBodyWithResponse(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegisteredModelResp, error)

	UpdateRegisteredModelWithResponse(ctx context.Context, fullName string, body UpdateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegisteredModelResp, error)

	// ListModelVersionsWithResponse request
	ListModelVersionsWithResponse(ctx context.Context, fullName string, params *ListModelVersionsParams, reqEditors ...RequestEditorFn) (*ListModelVersionsResp, error)

	// DeleteModelVersionWithResponse request
	DeleteModelVersionWithResponse(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*DeleteModelVersionResp, error)

	// GetModelVersionWithResponse request
	GetModelVersionWithResponse(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*GetModelVersionResp, error)

	// UpdateModelVersionWithBodyWithResponse request with any body
	UpdateModelVersionWithBodyWithResponse(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelVersionResp, error)

	UpdateModelVersionWithResponse(ctx context.Context, fullName string, version int64, body UpdateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelVersionResp, error)

	// FinalizeModelVersionWithBodyWithResponse request with any body
	FinalizeModelVersionWithBodyWithResponse(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FinalizeModelVersionResp, error)

	FinalizeModelVersionWithResponse(ctx context.Context, fullName string, version int64, body FinalizeModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*FinalizeModelVersionResp, error)

	// GetWithResponse request
	GetWithResponse(ctx context.Context, securableType SecurableType, fullName string, params *GetParams, reqEditors ...RequestEditorFn) (*GetResp, error)

	// UpdateWithBodyWithResponse request with any body
	UpdateWithBodyWithResponse(ctx context.Context, securableType SecurableType, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResp, error)

	UpdateWithResponse(ctx context.Context, securableType SecurableType, fullName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResp, error)

	// ListSchemasWithResponse request
	ListSchemasWithResponse(ctx context.Context, params *ListSchemasParams, reqEditors ...RequestEditorFn) (*ListSchemasResp, error)

	// CreateSchemaWithBodyWithResponse request with any body
	CreateSchemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaResp, error)

	CreateSchemaWithResponse(ctx context.Context, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaResp, error)

	// DeleteSchemaWithResponse request
	DeleteSchemaWithResponse(ctx context.Context, fullName string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResp, error)

	// GetSchemaWithResponse request
	GetSchemaWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetSchemaResp, error)

	// UpdateSchemaWithBodyWithResponse request with any body
	UpdateSchemaWithBodyWithResponse(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResp, error)

	UpdateSchemaWithResponse(ctx context.Context, fullName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResp, error)

	// ListTablesWithResponse request
	ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResp, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResp, error)

	CreateTableWithResponse(ctx context.Context, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResp, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*DeleteTableResp, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetTableResp, error)

	// GenerateTemporaryModelVersionCredentialsWithBodyWithResponse request with any body
	GenerateTemporaryModelVersionCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryModelVersionCredentialsResp, error)

	GenerateTemporaryModelVersionCredentialsWithResponse(ctx context.Context, body GenerateTemporaryModelVersionCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryModelVersionCredentialsResp, error)

	// GenerateTemporaryPathCredentialsWithBodyWithResponse request with any body
	GenerateTemporaryPathCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryPathCredentialsResp, error)

	GenerateTemporaryPathCredentialsWithResponse(ctx context.Context, body GenerateTemporaryPathCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryPathCredentialsResp, error)

	// GenerateTemporaryTableCredentialsWithBodyWithResponse request with any body
	GenerateTemporaryTableCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryTableCredentialsResp, error)

	GenerateTemporaryTableCredentialsWithResponse(ctx context.Context, body GenerateTemporaryTableCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryTableCredentialsResp, error)

	// GenerateTemporaryVolumeCredentialsWithBodyWithResponse request with any body
	GenerateTemporaryVolumeCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryVolumeCredentialsResp, error)

	GenerateTemporaryVolumeCredentialsWithResponse(ctx context.Context, body GenerateTemporaryVolumeCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryVolumeCredentialsResp, error)

	// ListVolumesWithResponse request
	ListVolumesWithResponse(ctx context.Context, params *ListVolumesParams, reqEditors ...RequestEditorFn) (*ListVolumesResp, error)

	// CreateVolumeWithBodyWithResponse request with any body
	CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResp, error)

	CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResp, error)

	// DeleteVolumeWithResponse request
	DeleteVolumeWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteVolumeResp, error)

	// GetVolumeWithResponse request
	GetVolumeWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetVolumeResp, error)

	// UpdateVolumeWithBodyWithResponse request with any body
	UpdateVolumeWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResp, error)

	UpdateVolumeWithResponse(ctx context.Context, name string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResp, error)
}

type ListCatalogsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCatalogsResponse
}

// Status returns HTTPResponse.Status
func (r ListCatalogsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCatalogsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCatalogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogInfo
}

// Status returns HTTPResponse.Status
func (r CreateCatalogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCatalogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCatalogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteCatalogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCatalogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCatalogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogInfo
}

// Status returns HTTPResponse.Status
func (r GetCatalogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCatalogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCatalogResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CatalogInfo
}

// Status returns HTTPResponse.Status
func (r UpdateCatalogResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCatalogResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFunctionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListFunctionsResponse
}

// Status returns HTTPResponse.Status
func (r ListFunctionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFunctionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FunctionInfo
}

// Status returns HTTPResponse.Status
func (r CreateFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFunctionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FunctionInfo
}

// Status returns HTTPResponse.Status
func (r GetFunctionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFunctionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegisteredModelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRegisteredModelsResponse
}

// Status returns HTTPResponse.Status
func (r ListRegisteredModelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegisteredModelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRegisteredModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredModelInfo
}

// Status returns HTTPResponse.Status
func (r CreateRegisteredModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRegisteredModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModelVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelVersionInfo
}

// Status returns HTTPResponse.Status
func (r CreateModelVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRegisteredModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteRegisteredModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRegisteredModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegisteredModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredModelInfo
}

// Status returns HTTPResponse.Status
func (r GetRegisteredModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegisteredModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRegisteredModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredModelInfo
}

// Status returns HTTPResponse.Status
func (r UpdateRegisteredModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRegisteredModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModelVersionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListModelVersionsResponse
}

// Status returns HTTPResponse.Status
func (r ListModelVersionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelVersionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModelVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteModelVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelVersionInfo
}

// Status returns HTTPResponse.Status
func (r GetModelVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModelVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelVersionInfo
}

// Status returns HTTPResponse.Status
func (r UpdateModelVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModelVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FinalizeModelVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModelVersionInfo
}

// Status returns HTTPResponse.Status
func (r FinalizeModelVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FinalizeModelVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionsList
}

// Status returns HTTPResponse.Status
func (r GetResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionsList
}

// Status returns HTTPResponse.Status
func (r UpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchemasResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSchemasResponse
}

// Status returns HTTPResponse.Status
func (r ListSchemasResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchemasResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSchemaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaInfo
}

// Status returns HTTPResponse.Status
func (r CreateSchemaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSchemaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSchemaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteSchemaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSchemaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchemaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaInfo
}

// Status returns HTTPResponse.Status
func (r GetSchemaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchemaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSchemaResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaInfo
}

// Status returns HTTPResponse.Status
func (r UpdateSchemaResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSchemaResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTablesResponse
}

// Status returns HTTPResponse.Status
func (r ListTablesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableInfo
}

// Status returns HTTPResponse.Status
func (r CreateTableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteTableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableInfo
}

// Status returns HTTPResponse.Status
func (r GetTableResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTemporaryModelVersionCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemporaryCredentials
}

// Status returns HTTPResponse.Status
func (r GenerateTemporaryModelVersionCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTemporaryModelVersionCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTemporaryPathCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemporaryCredentials
}

// Status returns HTTPResponse.Status
func (r GenerateTemporaryPathCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTemporaryPathCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTemporaryTableCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemporaryCredentials
}

// Status returns HTTPResponse.Status
func (r GenerateTemporaryTableCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTemporaryTableCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTemporaryVolumeCredentialsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TemporaryCredentials
}

// Status returns HTTPResponse.Status
func (r GenerateTemporaryVolumeCredentialsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTemporaryVolumeCredentialsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVolumesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListVolumesResponseContent
}

// Status returns HTTPResponse.Status
func (r ListVolumesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVolumesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeInfo
}

// Status returns HTTPResponse.Status
func (r CreateVolumeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVolumeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DeleteVolumeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVolumeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVolumeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeInfo
}

// Status returns HTTPResponse.Status
func (r GetVolumeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVolumeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVolumeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VolumeInfo
}

// Status returns HTTPResponse.Status
func (r UpdateVolumeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVolumeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCatalogsWithResponse request returning *ListCatalogsResp
func (c *ClientWithResponses) ListCatalogsWithResponse(ctx context.Context, params *ListCatalogsParams, reqEditors ...RequestEditorFn) (*ListCatalogsResp, error) {
	rsp, err := c.ListCatalogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCatalogsResp(rsp)
}

// CreateCatalogWithBodyWithResponse request with arbitrary body returning *CreateCatalogResp
func (c *ClientWithResponses) CreateCatalogWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCatalogResp, error) {
	rsp, err := c.CreateCatalogWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCatalogResp(rsp)
}

func (c *ClientWithResponses) CreateCatalogWithResponse(ctx context.Context, body CreateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCatalogResp, error) {
	rsp, err := c.CreateCatalog(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCatalogResp(rsp)
}

// DeleteCatalogWithResponse request returning *DeleteCatalogResp
func (c *ClientWithResponses) DeleteCatalogWithResponse(ctx context.Context, name string, params *DeleteCatalogParams, reqEditors ...RequestEditorFn) (*DeleteCatalogResp, error) {
	rsp, err := c.DeleteCatalog(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCatalogResp(rsp)
}

// GetCatalogWithResponse request returning *GetCatalogResp
func (c *ClientWithResponses) GetCatalogWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCatalogResp, error) {
	rsp, err := c.GetCatalog(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCatalogResp(rsp)
}

// UpdateCatalogWithBodyWithResponse request with arbitrary body returning *UpdateCatalogResp
func (c *ClientWithResponses) UpdateCatalogWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCatalogResp, error) {
	rsp, err := c.UpdateCatalogWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResp(rsp)
}

func (c *ClientWithResponses) UpdateCatalogWithResponse(ctx context.Context, name string, body UpdateCatalogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCatalogResp, error) {
	rsp, err := c.UpdateCatalog(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCatalogResp(rsp)
}

// ListFunctionsWithResponse request returning *ListFunctionsResp
func (c *ClientWithResponses) ListFunctionsWithResponse(ctx context.Context, params *ListFunctionsParams, reqEditors ...RequestEditorFn) (*ListFunctionsResp, error) {
	rsp, err := c.ListFunctions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFunctionsResp(rsp)
}

// CreateFunctionWithBodyWithResponse request with arbitrary body returning *CreateFunctionResp
func (c *ClientWithResponses) CreateFunctionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionResp, error) {
	rsp, err := c.CreateFunctionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResp(rsp)
}

func (c *ClientWithResponses) CreateFunctionWithResponse(ctx context.Context, body CreateFunctionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionResp, error) {
	rsp, err := c.CreateFunction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionResp(rsp)
}

// DeleteFunctionWithResponse request returning *DeleteFunctionResp
func (c *ClientWithResponses) DeleteFunctionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteFunctionResp, error) {
	rsp, err := c.DeleteFunction(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFunctionResp(rsp)
}

// GetFunctionWithResponse request returning *GetFunctionResp
func (c *ClientWithResponses) GetFunctionWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetFunctionResp, error) {
	rsp, err := c.GetFunction(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFunctionResp(rsp)
}

// ListRegisteredModelsWithResponse request returning *ListRegisteredModelsResp
func (c *ClientWithResponses) ListRegisteredModelsWithResponse(ctx context.Context, params *ListRegisteredModelsParams, reqEditors ...RequestEditorFn) (*ListRegisteredModelsResp, error) {
	rsp, err := c.ListRegisteredModels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegisteredModelsResp(rsp)
}

// CreateRegisteredModelWithBodyWithResponse request with arbitrary body returning *CreateRegisteredModelResp
func (c *ClientWithResponses) CreateRegisteredModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRegisteredModelResp, error) {
	rsp, err := c.CreateRegisteredModelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRegisteredModelResp(rsp)
}

func (c *ClientWithResponses) CreateRegisteredModelWithResponse(ctx context.Context, body CreateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRegisteredModelResp, error) {
	rsp, err := c.CreateRegisteredModel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRegisteredModelResp(rsp)
}

// CreateModelVersionWithBodyWithResponse request with arbitrary body returning *CreateModelVersionResp
func (c *ClientWithResponses) CreateModelVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModelVersionResp, error) {
	rsp, err := c.CreateModelVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelVersionResp(rsp)
}

func (c *ClientWithResponses) CreateModelVersionWithResponse(ctx context.Context, body CreateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModelVersionResp, error) {
	rsp, err := c.CreateModelVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModelVersionResp(rsp)
}

// DeleteRegisteredModelWithResponse request returning *DeleteRegisteredModelResp
func (c *ClientWithResponses) DeleteRegisteredModelWithResponse(ctx context.Context, fullName string, params *DeleteRegisteredModelParams, reqEditors ...RequestEditorFn) (*DeleteRegisteredModelResp, error) {
	rsp, err := c.DeleteRegisteredModel(ctx, fullName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRegisteredModelResp(rsp)
}

// GetRegisteredModelWithResponse request returning *GetRegisteredModelResp
func (c *ClientWithResponses) GetRegisteredModelWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetRegisteredModelResp, error) {
	rsp, err := c.GetRegisteredModel(ctx, fullName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegisteredModelResp(rsp)
}

// UpdateRegisteredModelWithBodyWithResponse request with arbitrary body returning *UpdateRegisteredModelResp
func (c *ClientWithResponses) UpdateRegisteredModelWithBodyWithResponse(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRegisteredModelResp, error) {
	rsp, err := c.UpdateRegisteredModelWithBody(ctx, fullName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegisteredModelResp(rsp)
}

func (c *ClientWithResponses) UpdateRegisteredModelWithResponse(ctx context.Context, fullName string, body UpdateRegisteredModelJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRegisteredModelResp, error) {
	rsp, err := c.UpdateRegisteredModel(ctx, fullName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRegisteredModelResp(rsp)
}

// ListModelVersionsWithResponse request returning *ListModelVersionsResp
func (c *ClientWithResponses) ListModelVersionsWithResponse(ctx context.Context, fullName string, params *ListModelVersionsParams, reqEditors ...RequestEditorFn) (*ListModelVersionsResp, error) {
	rsp, err := c.ListModelVersions(ctx, fullName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModelVersionsResp(rsp)
}

// DeleteModelVersionWithResponse request returning *DeleteModelVersionResp
func (c *ClientWithResponses) DeleteModelVersionWithResponse(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*DeleteModelVersionResp, error) {
	rsp, err := c.DeleteModelVersion(ctx, fullName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModelVersionResp(rsp)
}

// GetModelVersionWithResponse request returning *GetModelVersionResp
func (c *ClientWithResponses) GetModelVersionWithResponse(ctx context.Context, fullName string, version int64, reqEditors ...RequestEditorFn) (*GetModelVersionResp, error) {
	rsp, err := c.GetModelVersion(ctx, fullName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelVersionResp(rsp)
}

// UpdateModelVersionWithBodyWithResponse request with arbitrary body returning *UpdateModelVersionResp
func (c *ClientWithResponses) UpdateModelVersionWithBodyWithResponse(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModelVersionResp, error) {
	rsp, err := c.UpdateModelVersionWithBody(ctx, fullName, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelVersionResp(rsp)
}

func (c *ClientWithResponses) UpdateModelVersionWithResponse(ctx context.Context, fullName string, version int64, body UpdateModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModelVersionResp, error) {
	rsp, err := c.UpdateModelVersion(ctx, fullName, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModelVersionResp(rsp)
}

// FinalizeModelVersionWithBodyWithResponse request with arbitrary body returning *FinalizeModelVersionResp
func (c *ClientWithResponses) FinalizeModelVersionWithBodyWithResponse(ctx context.Context, fullName string, version int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FinalizeModelVersionResp, error) {
	rsp, err := c.FinalizeModelVersionWithBody(ctx, fullName, version, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFinalizeModelVersionResp(rsp)
}

func (c *ClientWithResponses) FinalizeModelVersionWithResponse(ctx context.Context, fullName string, version int64, body FinalizeModelVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*FinalizeModelVersionResp, error) {
	rsp, err := c.FinalizeModelVersion(ctx, fullName, version, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFinalizeModelVersionResp(rsp)
}

// GetWithResponse request returning *GetResp
func (c *ClientWithResponses) GetWithResponse(ctx context.Context, securableType SecurableType, fullName string, params *GetParams, reqEditors ...RequestEditorFn) (*GetResp, error) {
	rsp, err := c.Get(ctx, securableType, fullName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResp(rsp)
}

// UpdateWithBodyWithResponse request with arbitrary body returning *UpdateResp
func (c *ClientWithResponses) UpdateWithBodyWithResponse(ctx context.Context, securableType SecurableType, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResp, error) {
	rsp, err := c.UpdateWithBody(ctx, securableType, fullName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResp(rsp)
}

func (c *ClientWithResponses) UpdateWithResponse(ctx context.Context, securableType SecurableType, fullName string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResp, error) {
	rsp, err := c.Update(ctx, securableType, fullName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResp(rsp)
}

// ListSchemasWithResponse request returning *ListSchemasResp
func (c *ClientWithResponses) ListSchemasWithResponse(ctx context.Context, params *ListSchemasParams, reqEditors ...RequestEditorFn) (*ListSchemasResp, error) {
	rsp, err := c.ListSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchemasResp(rsp)
}

// CreateSchemaWithBodyWithResponse request with arbitrary body returning *CreateSchemaResp
func (c *ClientWithResponses) CreateSchemaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchemaResp, error) {
	rsp, err := c.CreateSchemaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaResp(rsp)
}

func (c *ClientWithResponses) CreateSchemaWithResponse(ctx context.Context, body CreateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchemaResp, error) {
	rsp, err := c.CreateSchema(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchemaResp(rsp)
}

// DeleteSchemaWithResponse request returning *DeleteSchemaResp
func (c *ClientWithResponses) DeleteSchemaWithResponse(ctx context.Context, fullName string, params *DeleteSchemaParams, reqEditors ...RequestEditorFn) (*DeleteSchemaResp, error) {
	rsp, err := c.DeleteSchema(ctx, fullName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSchemaResp(rsp)
}

// GetSchemaWithResponse request returning *GetSchemaResp
func (c *ClientWithResponses) GetSchemaWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetSchemaResp, error) {
	rsp, err := c.GetSchema(ctx, fullName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchemaResp(rsp)
}

// UpdateSchemaWithBodyWithResponse request with arbitrary body returning *UpdateSchemaResp
func (c *ClientWithResponses) UpdateSchemaWithBodyWithResponse(ctx context.Context, fullName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSchemaResp, error) {
	rsp, err := c.UpdateSchemaWithBody(ctx, fullName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResp(rsp)
}

func (c *ClientWithResponses) UpdateSchemaWithResponse(ctx context.Context, fullName string, body UpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSchemaResp, error) {
	rsp, err := c.UpdateSchema(ctx, fullName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSchemaResp(rsp)
}

// ListTablesWithResponse request returning *ListTablesResp
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, params *ListTablesParams, reqEditors ...RequestEditorFn) (*ListTablesResp, error) {
	rsp, err := c.ListTables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResp(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResp
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResp, error) {
	rsp, err := c.CreateTableWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResp(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResp, error) {
	rsp, err := c.CreateTable(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResp(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResp
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*DeleteTableResp, error) {
	rsp, err := c.DeleteTable(ctx, fullName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResp(rsp)
}

// GetTableWithResponse request returning *GetTableResp
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, fullName string, reqEditors ...RequestEditorFn) (*GetTableResp, error) {
	rsp, err := c.GetTable(ctx, fullName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResp(rsp)
}

// GenerateTemporaryModelVersionCredentialsWithBodyWithResponse request with arbitrary body returning *GenerateTemporaryModelVersionCredentialsResp
func (c *ClientWithResponses) GenerateTemporaryModelVersionCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryModelVersionCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryModelVersionCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryModelVersionCredentialsResp(rsp)
}

func (c *ClientWithResponses) GenerateTemporaryModelVersionCredentialsWithResponse(ctx context.Context, body GenerateTemporaryModelVersionCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryModelVersionCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryModelVersionCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryModelVersionCredentialsResp(rsp)
}

// GenerateTemporaryPathCredentialsWithBodyWithResponse request with arbitrary body returning *GenerateTemporaryPathCredentialsResp
func (c *ClientWithResponses) GenerateTemporaryPathCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryPathCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryPathCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryPathCredentialsResp(rsp)
}

func (c *ClientWithResponses) GenerateTemporaryPathCredentialsWithResponse(ctx context.Context, body GenerateTemporaryPathCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryPathCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryPathCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryPathCredentialsResp(rsp)
}

// GenerateTemporaryTableCredentialsWithBodyWithResponse request with arbitrary body returning *GenerateTemporaryTableCredentialsResp
func (c *ClientWithResponses) GenerateTemporaryTableCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryTableCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryTableCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryTableCredentialsResp(rsp)
}

func (c *ClientWithResponses) GenerateTemporaryTableCredentialsWithResponse(ctx context.Context, body GenerateTemporaryTableCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryTableCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryTableCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryTableCredentialsResp(rsp)
}

// GenerateTemporaryVolumeCredentialsWithBodyWithResponse request with arbitrary body returning *GenerateTemporaryVolumeCredentialsResp
func (c *ClientWithResponses) GenerateTemporaryVolumeCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTemporaryVolumeCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryVolumeCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryVolumeCredentialsResp(rsp)
}

func (c *ClientWithResponses) GenerateTemporaryVolumeCredentialsWithResponse(ctx context.Context, body GenerateTemporaryVolumeCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateTemporaryVolumeCredentialsResp, error) {
	rsp, err := c.GenerateTemporaryVolumeCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTemporaryVolumeCredentialsResp(rsp)
}

// ListVolumesWithResponse request returning *ListVolumesResp
func (c *ClientWithResponses) ListVolumesWithResponse(ctx context.Context, params *ListVolumesParams, reqEditors ...RequestEditorFn) (*ListVolumesResp, error) {
	rsp, err := c.ListVolumes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVolumesResp(rsp)
}

// CreateVolumeWithBodyWithResponse request with arbitrary body returning *CreateVolumeResp
func (c *ClientWithResponses) CreateVolumeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVolumeResp, error) {
	rsp, err := c.CreateVolumeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResp(rsp)
}

func (c *ClientWithResponses) CreateVolumeWithResponse(ctx context.Context, body CreateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVolumeResp, error) {
	rsp, err := c.CreateVolume(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeResp(rsp)
}

// DeleteVolumeWithResponse request returning *DeleteVolumeResp
func (c *ClientWithResponses) DeleteVolumeWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteVolumeResp, error) {
	rsp, err := c.DeleteVolume(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVolumeResp(rsp)
}

// GetVolumeWithResponse request returning *GetVolumeResp
func (c *ClientWithResponses) GetVolumeWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetVolumeResp, error) {
	rsp, err := c.GetVolume(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVolumeResp(rsp)
}

// UpdateVolumeWithBodyWithResponse request with arbitrary body returning *UpdateVolumeResp
func (c *ClientWithResponses) UpdateVolumeWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVolumeResp, error) {
	rsp, err := c.UpdateVolumeWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResp(rsp)
}

func (c *ClientWithResponses) UpdateVolumeWithResponse(ctx context.Context, name string, body UpdateVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVolumeResp, error) {
	rsp, err := c.UpdateVolume(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVolumeResp(rsp)
}

// ParseListCatalogsResp parses an HTTP response from a ListCatalogsWithResponse call
func ParseListCatalogsResp(rsp *http.Response) (*ListCatalogsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCatalogsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCatalogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCatalogResp parses an HTTP response from a CreateCatalogWithResponse call
func ParseCreateCatalogResp(rsp *http.Response) (*CreateCatalogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCatalogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCatalogResp parses an HTTP response from a DeleteCatalogWithResponse call
func ParseDeleteCatalogResp(rsp *http.Response) (*DeleteCatalogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCatalogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCatalogResp parses an HTTP response from a GetCatalogWithResponse call
func ParseGetCatalogResp(rsp *http.Response) (*GetCatalogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCatalogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCatalogResp parses an HTTP response from a UpdateCatalogWithResponse call
func ParseUpdateCatalogResp(rsp *http.Response) (*UpdateCatalogResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCatalogResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CatalogInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFunctionsResp parses an HTTP response from a ListFunctionsWithResponse call
func ParseListFunctionsResp(rsp *http.Response) (*ListFunctionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFunctionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListFunctionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFunctionResp parses an HTTP response from a CreateFunctionWithResponse call
func ParseCreateFunctionResp(rsp *http.Response) (*CreateFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FunctionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFunctionResp parses an HTTP response from a DeleteFunctionWithResponse call
func ParseDeleteFunctionResp(rsp *http.Response) (*DeleteFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFunctionResp parses an HTTP response from a GetFunctionWithResponse call
func ParseGetFunctionResp(rsp *http.Response) (*GetFunctionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFunctionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FunctionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRegisteredModelsResp parses an HTTP response from a ListRegisteredModelsWithResponse call
func ParseListRegisteredModelsResp(rsp *http.Response) (*ListRegisteredModelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegisteredModelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRegisteredModelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRegisteredModelResp parses an HTTP response from a CreateRegisteredModelWithResponse call
func ParseCreateRegisteredModelResp(rsp *http.Response) (*CreateRegisteredModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRegisteredModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredModelInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateModelVersionResp parses an HTTP response from a CreateModelVersionWithResponse call
func ParseCreateModelVersionResp(rsp *http.Response) (*CreateModelVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModelVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelVersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRegisteredModelResp parses an HTTP response from a DeleteRegisteredModelWithResponse call
func ParseDeleteRegisteredModelResp(rsp *http.Response) (*DeleteRegisteredModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRegisteredModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegisteredModelResp parses an HTTP response from a GetRegisteredModelWithResponse call
func ParseGetRegisteredModelResp(rsp *http.Response) (*GetRegisteredModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegisteredModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredModelInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRegisteredModelResp parses an HTTP response from a UpdateRegisteredModelWithResponse call
func ParseUpdateRegisteredModelResp(rsp *http.Response) (*UpdateRegisteredModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRegisteredModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredModelInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListModelVersionsResp parses an HTTP response from a ListModelVersionsWithResponse call
func ParseListModelVersionsResp(rsp *http.Response) (*ListModelVersionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModelVersionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListModelVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteModelVersionResp parses an HTTP response from a DeleteModelVersionWithResponse call
func ParseDeleteModelVersionResp(rsp *http.Response) (*DeleteModelVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModelVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModelVersionResp parses an HTTP response from a GetModelVersionWithResponse call
func ParseGetModelVersionResp(rsp *http.Response) (*GetModelVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelVersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateModelVersionResp parses an HTTP response from a UpdateModelVersionWithResponse call
func ParseUpdateModelVersionResp(rsp *http.Response) (*UpdateModelVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModelVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelVersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFinalizeModelVersionResp parses an HTTP response from a FinalizeModelVersionWithResponse call
func ParseFinalizeModelVersionResp(rsp *http.Response) (*FinalizeModelVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FinalizeModelVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModelVersionInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResp parses an HTTP response from a GetWithResponse call
func ParseGetResp(rsp *http.Response) (*GetResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResp parses an HTTP response from a UpdateWithResponse call
func ParseUpdateResp(rsp *http.Response) (*UpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSchemasResp parses an HTTP response from a ListSchemasWithResponse call
func ParseListSchemasResp(rsp *http.Response) (*ListSchemasResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchemasResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSchemasResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSchemaResp parses an HTTP response from a CreateSchemaWithResponse call
func ParseCreateSchemaResp(rsp *http.Response) (*CreateSchemaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSchemaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSchemaResp parses an HTTP response from a DeleteSchemaWithResponse call
func ParseDeleteSchemaResp(rsp *http.Response) (*DeleteSchemaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSchemaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchemaResp parses an HTTP response from a GetSchemaWithResponse call
func ParseGetSchemaResp(rsp *http.Response) (*GetSchemaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchemaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSchemaResp parses an HTTP response from a UpdateSchemaWithResponse call
func ParseUpdateSchemaResp(rsp *http.Response) (*UpdateSchemaResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSchemaResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTablesResp parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResp(rsp *http.Response) (*ListTablesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTablesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableResp parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResp(rsp *http.Response) (*CreateTableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTableResp parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResp(rsp *http.Response) (*DeleteTableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTableResp parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResp(rsp *http.Response) (*GetTableResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateTemporaryModelVersionCredentialsResp parses an HTTP response from a GenerateTemporaryModelVersionCredentialsWithResponse call
func ParseGenerateTemporaryModelVersionCredentialsResp(rsp *http.Response) (*GenerateTemporaryModelVersionCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTemporaryModelVersionCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemporaryCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateTemporaryPathCredentialsResp parses an HTTP response from a GenerateTemporaryPathCredentialsWithResponse call
func ParseGenerateTemporaryPathCredentialsResp(rsp *http.Response) (*GenerateTemporaryPathCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTemporaryPathCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemporaryCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateTemporaryTableCredentialsResp parses an HTTP response from a GenerateTemporaryTableCredentialsWithResponse call
func ParseGenerateTemporaryTableCredentialsResp(rsp *http.Response) (*GenerateTemporaryTableCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTemporaryTableCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemporaryCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateTemporaryVolumeCredentialsResp parses an HTTP response from a GenerateTemporaryVolumeCredentialsWithResponse call
func ParseGenerateTemporaryVolumeCredentialsResp(rsp *http.Response) (*GenerateTemporaryVolumeCredentialsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTemporaryVolumeCredentialsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TemporaryCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListVolumesResp parses an HTTP response from a ListVolumesWithResponse call
func ParseListVolumesResp(rsp *http.Response) (*ListVolumesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVolumesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListVolumesResponseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeResp parses an HTTP response from a CreateVolumeWithResponse call
func ParseCreateVolumeResp(rsp *http.Response) (*CreateVolumeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVolumeResp parses an HTTP response from a DeleteVolumeWithResponse call
func ParseDeleteVolumeResp(rsp *http.Response) (*DeleteVolumeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVolumeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVolumeResp parses an HTTP response from a GetVolumeWithResponse call
func ParseGetVolumeResp(rsp *http.Response) (*GetVolumeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVolumeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateVolumeResp parses an HTTP response from a UpdateVolumeWithResponse call
func ParseUpdateVolumeResp(rsp *http.Response) (*UpdateVolumeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVolumeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VolumeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
